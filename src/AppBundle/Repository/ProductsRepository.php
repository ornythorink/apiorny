<?php

namespace AppBundle\Repository;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\Tools\Pagination\Paginator;
use Doctrine\ORM\Query\ResultSetMappingBuilder;

/**
 * ProductsRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ProductsRepository extends EntityRepository
{
    public function getArrayById($locale, $id)
    {

        $sql = '
                   SELECT s.*
                   FROM products AS s
                   WHERE s.id = :id
                   AND s.locale = :locale
                   AND (s.status = "Ok" OR s.status = "Validation")
                   ';

        $params['id']  = $id;
        $params['locale']  = $locale;
        $stmt = $this->_em->getConnection()->prepare($sql);
        $stmt->execute($params);



        $results = $stmt->fetchAll();
//        echo '<pre>';
//        var_dump($results);
//        exit;
        return $results;
    }

    public function searchProducts($term, $locale, $single = false)
    {

        $data = array();
        $term1 = $term;
        $term2 = $term1;

        $sql = '
                  SELECT s.* ,
                            MATCH(s.name,s.description)
                                    AGAINST (:term) as Relevance
                   FROM products AS s
                   WHERE (s.status = "Ok" OR s.status = "Validation")
                   AND locale = :locale
                      AND    MATCH (s.name,s.description)  AGAINST( :term2 IN  BOOLEAN MODE)
                   HAVING Relevance > 0
                   ORDER BY Relevance DESC
                   LIMIT :minus , :max ';

        // @todo pourquoi 2 termes ? chevrons ?

        $stmt = $this->_em->getConnection()->prepare($sql);

        $stmt->bindValue('term', $term1);
        $stmt->bindValue('term2', $term2);
        $stmt->bindValue('locale', $locale);
        if ($single === false)
        {
            $stmt->bindValue('minus', 0, \PDO::PARAM_INT);
            $stmt->bindValue('max', 100, \PDO::PARAM_INT);
        } else {
            $stmt->bindValue('minus', 0, \PDO::PARAM_INT);
            $stmt->bindValue('max', 1, \PDO::PARAM_INT);
        }


        $stmt->execute();

        $results = $stmt->fetchAll();
//        echo '<pre>';
//        var_dump($results);exit;
//        foreach($results as $item)
//        {
//            $data[] = $item;
//        }
        return $results;
    }

    public function searchSelectedProduct($term, $locale, $id)
    {

        $data = array();
        $term1 = $term;
        $term2 = $term1;

        $sql = '
                  SELECT s.* ,
                            MATCH(s.name,s.description)
                                    AGAINST (:term) as Relevance
                   FROM products AS s
                   WHERE (status = "Ok" OR status = "Validation")
                   AND locale = :locale
                   AND id = :id
                      AND    MATCH (s.name,s.description)  AGAINST( :term2 IN  BOOLEAN MODE)
                   HAVING Relevance > 0
                   ORDER BY Relevance DESC
                   LIMIT :minus , :max

                   ';

        // @todo pourquoi 2 termes ? chevrons ?

        $stmt = $this->_em->getConnection()->prepare($sql);

        $stmt->bindValue('term', $term1);
        $stmt->bindValue('term2', $term2);
        $stmt->bindValue('locale', $locale);
        $stmt->bindValue('id', $id);
        $stmt->bindValue('minus', 0, \PDO::PARAM_INT);
        $stmt->bindValue('max', 1, \PDO::PARAM_INT);

        $stmt->execute();

        $results = $stmt->fetchAll();
//        echo '<pre>';
//        var_dump($results);exit;
//        foreach($results as $item)
//        {
//            $data[] = $item;
//        }
        return $results;
    }


    public function searchLinkedProducts($term, $locale, $thresold)
    {

        $data = array();
        $term1 = $term;
        $term2 = $term1;

        $sql = '
                  SELECT s.* ,
                            MATCH(s.name,s.description)
                                    AGAINST (:term) AS Relevance
                   FROM products AS s
                   WHERE (status = "Ok" OR status = "Validation")
                   AND locale = :locale
                      AND    MATCH (s.name,s.description)  AGAINST( :term2 IN  BOOLEAN MODE)
                   HAVING Relevance > :thresold
                   ORDER BY Relevance DESC
                   LIMIT :minus , :max

                   ';

        // @todo pourquoi 2 termes ? chevrons ?


        //var_dump($sql);
        $stmt = $this->_em->getConnection()->prepare($sql);

        $stmt->bindValue('term', $term1);
        $stmt->bindValue('term2', $term2);
        $stmt->bindValue('locale', $locale);
        $stmt->bindValue('minus', 0, \PDO::PARAM_INT);
        $stmt->bindValue('max', 5, \PDO::PARAM_INT);
        $stmt->bindValue('thresold', $thresold, \PDO::PARAM_STR);

        $stmt->execute();

        $results = $stmt->fetchAll();
//        foreach ($results as $item) {
//            $data[] = $item;
//        }
        return $results;
    }

    public function getLeadProducts($term, $locale)
    {

        $data = array();
        $term1 = $term;
        $term2 = $term1;

        $sql = '
                  SELECT s.* ,
                            MATCH(s.name,s.description)
                                    AGAINST (:term) AS Relevance
                   FROM products AS s
                   WHERE (status = "Ok" OR status = "Validation")
                   AND locale = :locale
                      AND    MATCH (s.name,s.description)  AGAINST( :term2 IN  BOOLEAN MODE)
                   ORDER BY Relevance DESC
                   LIMIT 0 , 1
                   ';

        $stmt = $this->_em->getConnection()->prepare($sql);

        $stmt->bindValue('term', $term1);
        $stmt->bindValue('term2', $term2);
        $stmt->bindValue('locale', $locale);

        $stmt->execute();

        $results = $stmt->fetchAll();
        return $results;
    }

    public function searchProductsByTag($term, $locale , $source)
    {
        $data = array();
        $api = strtoupper($source);
        $term2 = ">".implode(' >',explode(' ',$term));

        $sql = '
                  SELECT u.* ,
                            MATCH(s.name,s.description,s.category_merchant)
                                    AGAINST (:term) as Relevance
                   FROM FulltextProducts  AS s
                   INNER JOIN Products AS u ON s.id = u.id
                   INNER JOIN products_tags t ON u.id = t. products_id
                   INNER JOIN tag t2 ON t2.id = t.tag_id
                   WHERE source_id = :api AND
                            MATCH (s.name,s.description,s.category_merchant)  AGAINST( :term2 IN  BOOLEAN MODE)
                   AND status = "Ok"
                   GROUP BY u.name
                   ORDER BY Relevance DESC
                   LIMIT 0 , 100
                   ';

        $params['term']  = $term;
        $params['api']   = $api;
        $params['term2'] = $term2;

        $stmt = $this->_em->getConnection()->prepare($sql);
        $stmt->execute($params);

        $results = $stmt->fetchAll();
        foreach($results as $item)
        {
            $data[] = $item;
        }
        return $data;
    }

    public function getLinkedProducts($id)
    {
        $sourceType = 'CSV';

       $sql = '
                SELECT
                 p.*
                FROM Products p
                INNER JOIN linked l ON p.id_api = l.`linked_ api_id`
                WHERE l.product_api_id = :id
                GROUP BY p.id_api
                LIMIT 4   ';
               $params['id']  = $id;
        $stmt = $this->_em->getConnection()->prepare($sql);
        $stmt->execute($params);

        $rows = $stmt->fetchAll();
        $results = array();
        foreach($rows as $row)
        {
            $results[] = Products::bulkCreate($sourceType, $row);
        }

        return $results;
    }

    public function getTaggedProductsByTag($tag)
    {
        $sql = <<<EOL
                SELECT
                  *
                FROM Products p
                INNER JOIN products_tags t ON p.id = t. products_id
                INNER JOIN tag t2 ON t2.id = t. tag_id
                WHERE t2.tagslug = :tag
EOL;


        $params['tag']  = $tag;
        $stmt = $this->_em->getConnection()->prepare($sql);
        $stmt->execute($params);

        $results = $stmt->fetchAll();
        return $results;
    }



    /**
     * Get the paginated list of published articles
     *
     * @param int $page
     * @param int $maxperpage
     * @param string $sortby
     * @return Paginator
     */
    public function getPaginatedProductsToValidate($page=1, $maxperpage=10)
    {
        $q = $this->_em->createQueryBuilder()
            ->select('produits')
            ->from('ProductOld.php','produits')
            ->where('produits.status = :status ')
            ->setParameter('status' , "Validation" )
        ;
    
        $q->setFirstResult(($page-1) * $maxperpage)
            ->setMaxResults($maxperpage);
 
        return new Paginator($q);
    }

    public function findSimilarImageHash($hash, $dbh)
    {
        /*$query = $this->_em->createQuery(
            "
                SELECT
                  p
                FROM AppBundle:Products p
                WHERE p.imagehash = :imagehash
            "
        );*/
/*
        $query  = $this->_em->createQueryBuilder()
        ->select(array('b'))
        ->from( 'AppBundle:Products' , 'b')
        ->where('BIT_COUNT( b.imagehash ^  :imagehash ) <= 4')
        ->setParameter('imagehash', $hash)->getQuery();*/
        /* Ex�cute une requ�te pr�par�e en liant des variables PHP */


        $prepare= $dbh->prepare("
        SELECT *, BIT_COUNT(
        imagehash ^ :hash ) as hamming_distance
        FROM Products
        WHERE status = 'Ok'
        HAVING hamming_distance < 4
        ORDER BY hamming_distance ASC
        ");
        $prepare->bindParam(":hash",$hash);
        $prepare->execute();
        $results = $prepare->fetchAll();

        return $results;
    }

    public function countItems()
    {
        return $this->createQueryBuilder('a')
            ->select('COUNT(a)')
            ->getQuery()
            ->getSingleScalarResult();
    }

    public function getBunchOfTags($limit)
    {
        $maxLimit = $limit + 2000;

        $rsm = new ResultSetMappingBuilder($this->getEntityManager());
        $rsm->addRootEntityFromClassMetadata('AppBundle\Entity\Products', 'u');

        $sql =     "SELECT description
                    FROM Products p  LIMIT ? , ?
                    WHERE status = 'Ok' ";
        // 3. Run the query
        $query = $this->_em->createNativeQuery($sql, $rsm);
        $query->setParameter(1, $limit);
        $query->setParameter(2, $maxLimit);


        $results = $query->getArrayResult();
        foreach($results as $item)
        {
            $data[] = $item;
        }

        return $data;

    }

    public function findLatest()
    {

        $sql = <<<SQL

                SELECT
                  p.*
                FROM Products p
                WHERE p.status = 'Ok'

                ORDER BY RAND()
                LIMIT 0, 100

SQL;

        $stmt = $this->_em->getConnection()->prepare($sql);

        $date = new \DateTime('NOW');
        $date->modify('-15 day');
        $h48 =  $date->format('Y-m-d H:i:s');
        $params['h48'] = $h48;

        $stmt->execute($params);

        $results = $stmt->fetchAll();
        return $results;
    }


}
